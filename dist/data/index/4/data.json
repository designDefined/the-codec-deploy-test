{
  "id": 4,
  "title": "Be Water, My Layout: CSS Flexbox가 제시하는 레이아웃 스타일링의 새로운 관점",
  "content": {
    "id": "root-sample",
    "title": "root",
    "type": "OUTER_BOX",
    "layout": { "g": 48 },
    "children": [
      {
        "id": "container-sample",
        "title": "sample",
        "type": "INNER_BOX",
        "children": [{ "type": "HEADING", "level": 1, "children": [{ "text": "Be Water, My Layout" }] }]
      },
      {
        "id": "PiLjgqjWrpmbudYGcx3T3",
        "title": "new box 2",
        "type": "INNER_BOX",
        "children": [{ "type": "PARAGRAPH", "children": [{ "text": "CSS Flexbox로 레이아웃 모듈화하기" }] }]
      },
      {
        "id": "hT_FpOw50digm1pnzIWY2",
        "title": "new box 3",
        "type": "INNER_BOX",
        "children": [{ "type": "PARAGRAPH", "children": [{ "text": "인트로1" }] }]
      },
      {
        "id": "4THaNi07UoIsJK6UDzxwn",
        "title": "new box 4",
        "type": "INNER_BOX",
        "children": [{ "type": "PARAGRAPH", "children": [{ "text": "인트로2" }] }]
      },
      {
        "id": "4xz_PehhoIPeEGq3BRMlE",
        "title": "new box 5",
        "type": "INNER_BOX",
        "children": [
          {
            "type": "HEADING",
            "level": 2,
            "children": [{ "text": "CSS로 레이아웃을 그리기가 어려운 이유", "bold": true }]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "CSS 작업은 즐겁습니다. 단순히 코드 조각에 불과했던 UI가 비로소 " },
              { "text": "눈에 보이는 실체", "bold": true },
              {
                "text": "로 거듭나는 순간이기 때문입니다. 코드 한 줄 한 줄이 화면 전체의 인상을 바꾸거나, UI를 살아 숨쉬는 상호작용의 주체로 만들기도 하죠. 그러나"
              },
              { "text": " CSS는 상당히 어렵습니다. ", "bold": false },
              {
                "text": "프론트엔드 개발자라면 분명 마음대로 되지 않는 CSS 때문에 밤을 지새워본 적이 있을 겁니다. 화면을 너무 복잡하게 구현한 디자이너나, 이해할 수 없는 CSS 문법을 도입한 선대의 웹 개발자들을 원망하면서 말이죠. "
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "저의 경우에는 화면의 " },
              { "text": "레이아웃 작업", "bold": true },
              {
                "text": ", 즉 UI 요소들을 화면의 적절한 위치에 배치하는 일이 특히 까다롭게 느껴졌습니다. 물론 프로젝트의 초기에는 "
              },
              { "text": "디자인 시스템을 구현", "bold": false },
              {
                "text": "하거나 색상이나 폰트와 같은 서비스 전반의 테마를 잡는 데 시간을 많이 소모합니다. 그러나 프로젝트가 점점 확장될수록 점점 부담스러워지는 작업은 바로, 새로운 화면의 레이아웃을 잡거나 기존의 레이아웃을 수정하는 것입니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "CSS의 레이아웃은, " },
              { "text": "깨끗하지 않습니다.", "bold": true },
              { "text": " 디자인의 퀄리티에 대한 이야기가 아닙니다. 구조에 관한 이야기입니다.", "bold": false },
              { "text": " " },
              { "text": "'클린 아키텍쳐'", "bold": false },
              { "text": "에서 로버트 C. 마틴은 " },
              { "text": "\"구조는 변경에 닫혀있고 확장에 열려있어야 한다\" ", "italic": true, "bold": false },
              { "text": "라 말했습니다. 그러나 아래의 세 가지 이유로 레이아웃은 프론트엔드 개발에서" },
              { "text": " 가장 더러운", "bold": false },
              { "bold": true, "text": " " },
              { "text": "부분이 되곤 합니다.", "bold": false }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "첫째, 레이아웃은 너무 " },
              { "text": "각양각색", "bold": true },
              {
                "text": "입니다. 페이지가 10개, 20개 늘어나더라도 버튼 디자인의 가짓수는 크게 늘어나지 않습니다. 텍스트 입력창이나 모달, 셀렉트박스의 디자인도 마찬가지죠. 기존의 컴포넌트를 재사용할 수 있기 때문입니다. 그러나 그 페이지들이 "
              },
              { "text": "모두 다른 레이아웃을 가지고 있다", "bold": true },
              { "text": "고 해도 그리 놀랍지는 않습니다. 화면의 기능과 사용 방법에 따라 요소들" },
              { "text": "의 배치를 최적화해야 하기 때문입니다. ", "bold": false },
              {
                "text": "서로 다른 기능을 가진 10개의 페이지가 추가되었다면, 이에 최적화된 10개의 레이아웃 또한 추가되는 것이죠. 레이아웃 작업은 "
              },
              { "text": "UI의 확장이 느려지는", "bold": true },
              { "text": " 주요 원인입니다." }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "둘째, CSS로 요소를 배치하는 작업은 " },
              { "text": "직관적이지 않습니다", "bold": true },
              {
                "text": ". 드래그 & 드롭으로 UI를 눈에 보이는 위치에 배치할 수 있다면 좋겠지만 CSS는 그렇지 않습니다. 우리는 padding, margin, gap과 같은 속성으로 부모와 자식 요소들과의 거리를 조절하며 레이아웃을 '쌓아올려야' 하고, 정렬 하나를 위해서도 float와 flex, align, justify, wrap 등 수많은 속성을 알아야 합니다. 작업을 하다보면 단지 레이아웃만을 위한 HTML 태그들이 추가됩니다. 여기에는 .container, .wrapper, .wrapper-container와 같은 추상적인 클래스명이 붙고, 이는 코드의 가독성을 크게 떨어뜨리죠. 이 클래스들에 붙은 속성 한 줄이 화면의 구조를 완전히 바꿔버릴 수도 있는데도 말입니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "셋째, 그럼에도 불구하고 레이아웃은 " },
              { "text": "자주 수정됩니다", "bold": true },
              {
                "text": ". 새로운 요소가 추가되면 기존의 레이아웃은 전반적으로 영향을 받습니다. 새로운 요소를 위한 공간을 확보하고. 뿐만 아니라 기능에 변경이 없더라도 사용자의 편의를 위해 요소를 재배치하는 일도 종종 일어나죠. 가독성이 떨어지고 영향을 미치는 범위가 넓은 코드를 자주 고치게 되면 오류가 많이 발생할 수 밖에 없습니다. 즉, 레이아웃은 UI의 변경과 유지보수를 어렵고 위험하게 만드는 것입니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "레이아웃은 " },
              { "text": "디자인 시스템 바깥의 디자인", "bold": true },
              {
                "text": "입니다. 모듈화할 수도 없고, 재사용하기도 어렵습니다. 레이아웃의 요구는 종종 잘 정립된 디자인 시스템에 영향을 주기도 합니다. 배치에 따라 기존 요소의 크기, 간격, 줄바꿈이나 스크롤 여부 등을 미세 조정해야하기 때문입니다. 개발자는 디자인 시스템 컴포넌트에 커스텀 속성을 계속 추가하거나, 디자이너와 담판을 짓는 것 중 하나를 선택해야 합니다. 어느 쪽이든 소모적이기는 마찬가지이죠."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "text": "그러나 저는 CSS를 사용하면서도 레이아웃과 디자인 시스템, 즉 UI 작업의 더러운 부분과 깨끗한 부분이 조화를 이룰 수 있다고 봅니다. 바로 "
              },
              { "text": "Flexbox", "bold": true },
              { "text": "를 이용한다면 말입니다." }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "text": "" }] }
        ]
      },
      {
        "id": "5K7u6fkeH4zh1LV6t824K",
        "title": "new box 6",
        "type": "INNER_BOX",
        "children": [
          { "type": "PARAGRAPH", "children": [{ "text": "Flexbox가 제시하는 레이아웃의 모듈화 방법", "bold": true }] },
          {
            "type": "PARAGRAPH",
            "children": [
              { "text": "Flexbox는 CSS에 내재되어 있는 일차원 레이아웃 시스템인 '", "bold": false },
              { "bold": true, "text": "Flexible Box Module" },
              {
                "bold": false,
                "text": "'의 줄임말입니다. 흔히 `display: flex` 속성이 선언된 요소가 가지게 되죠. 이 시스템 자체가 익숙하지 않더라도, 여러분은 캐러셀의 항목들을 가로로 배치하거나 글자를 `<div>` 한가운데로 보낼 때 이 속성을 한 번쯤은 사용해보았을 겁니다. "
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "그러나 이를 Flexbox의 존재 이유라 보기는 어렵습니다. Flexbox의 요점은 부모 요소에서 자식으로, 또는 자식 요소로부터 부모로 가해지는 "
              },
              { "bold": true, "text": "두 가지 방향의 힘" },
              {
                "bold": false,
                "text": "을 개발자가 통제할 수 있게 한다는 데 있습니다. 레이아웃을 모듈화하기 위해서는 이러한 관점에서 Flexbox를 바라볼 수 있어야 합니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "" }] },
          { "type": "PARAGRAPH", "children": [{ "text": "부모에서 자식으로: 흐름 제어", "bold": true }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "text": "한 번 생각해봅시다. 왜 `<div>`와 같은 블록 요소들의 기본값은 항상 화면의 폭을 가득 채우며, 위에서 아래로 배치되는 것일까요? 이는 block`이나 `inline` 요소가 내재적으로 갖고 있는 흐름 때문입니다. 하지만 Flexbox는 부모 요소로부터 자식 요소들이 지닌 ",
                "bold": false
              },
              { "bold": true, "text": "레이아웃의 흐름" },
              {
                "text": "을 통제할 수 있게 합니다. 자식 요소가 어떤 display 속성을 가지고 있건 말이죠. 이것이 Flexbox가 지닌 첫 번째 힘입니다.",
                "bold": false
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              { "bold": false, "text": "Flexbox에서의 흐름이란 " },
              { "bold": true, "text": "일차원 축의 방향" },
              { "bold": false, "text": "과 여기서 파생되는 " },
              { "bold": true, "text": "두 가지의 정렬 방식" },
              { "bold": false, "text": "을 결정하는 것을 의미합니다. " },
              { "bold": true, "text": "축의 방향" },
              {
                "bold": false,
                "text": "은 `flex-direction`속성으로 쉽게 제어할 수 있는데, 여기서 Flexbox는 block 요소와 다르게 가로와 세로, 정방향과 역방향이라는 2*2의 선택지를 제공합니다. 우리가 캐러셀의 항목들을 가로로 배치할 때 Flexbox를 이용하는 이유는 축의 방향을 변화시키 위함이라고 볼 수 있겠습니다. "
              },
              { "bold": true, "text": "정렬" },
              { "bold": false, "text": "은 \b" },
              { "bold": true, "text": "주 축" },
              { "bold": false, "text": "(main axis)의 방향에 따른 정렬(justify-content)과 " },
              { "bold": true, "text": "수직 축" },
              {
                "text": "(cross axis)의 방향에 따른 정렬(align-items)을 결정하는 두 가지 속성으로 제어할 수 있습니다. Flexbox가 일차원 레이아웃 시스템임에도 불구하고 이차원인 UI의 레이아웃을 온전히 제어할 수 있는 이유는 이처럼 요소 간의 축의 방향을 서로 수직이게 설정할 수도 있고, 그 내부 요소들 또한 수직과 수평의 두 관점에서 정렬할 수 있기 때문입니다.",
                "bold": false
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "위에서 언급한 속성들은 `display: flex` 속성을 가진 요소 자체의 위치나 크기를 결정하지 않지만, 그 자식 요소들의 폭이나 박스 모델에 영향을 줍니다. border-box 환경에서의 padding 속성처럼 말이죠. 부모 요소가 자식 요소에게 가하는 힘인 것입니다. 그러나 흐름이 아니라 길이의 관점에서는 반대로 자식 요소가 부모 요소에게 요청을 보내기도 합니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "" }] },
          { "type": "PARAGRAPH", "children": [{ "text": "내부에서 외부로: 길이 분배하기", "bold": true }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "당연한 사실에 대한 의문 하나 더: 대부분의 웹사이트는 세로 방향으로 스크롤이 생기지만, 가로 방향으로는 생기지 않습니다. 왜일까요? 물론 '대부분의 마우스휠은 세로로 스크롤하기가 편해서'와 같은 사용성 측면의 답변도 나올 수 있겠지만, CSS의 관점에서 답변한다면 "
              },
              { "bold": true, "text": "웹사이트의 주 축은 세로 방향" },
              { "bold": false, "text": "이기 때문이라고 말할 수 있을 것입니다. " }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "주 축 방향으로의 스크롤은 자연스럽지만 수직 방향의 스크롤은 어색합니다. 주 축의 길이는 페이지의 '중심 내용'의 길이를 의미하고, 이 주 내용은 무한히 늘어날 수 있어야 하기 때문입니다. 세 문단 이상을 본문에 적을 수 없는 블로그의 레이아웃은 실용적이지 않겠죠. 다섯 개 이상의 할 일을 등록할 수 없는 투두 리스트도 마찬가지입니다. 레이아웃은 아무리 긴 내용도 담을 수 있어야 합니다. 그리고 중심 내용 언제나(inline-block 환경이나 Flexbox의 환경에서 모두) 주 축의 방향으로 나열됩니다. 그래서 주 축 방향으로 스크롤이 생기는 상황은 자연스럽게 느껴지는 것입니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "이 이야기를 꺼낸 이유는 Flexbox의 내부, 즉 자식 요소가 Flexbox, 즉 부모 요소에 가하는 힘에 대해 설명하기 위함입니다. 부모 요소가 주 축 방향으로 얼마나 길어질 지, 또는 스크롤을 이용하여 얼마만큼의 길이를 자식 요소에게 확보해줄 지는 부모 요소가 결정할 수 없습니다. 또 자식 요소의 길이를 원하는 대로 결정해서 도 안 되고요. 'justify-content: stretch' 같은 속성이 존재하지 않는 이유도 같은 맥락에서일 겁니다. 대신 이 길이는 자식 요소가 부모에게 요청하고 확보해내며, 그 결과 부모 요소에 스크롤이 생기거나 내부의 내용이 잘리게 됩니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "그렇다면 자식은 어떤 방식으로 부모 요소에게 공간, 즉 길이를 요청하게 될까요? Flexbox의 내부 요소들은 기존의 block처럼 고정된 길이 또는 부모에 대한 비율을 선언하는 대신 훨씬 유연한 방법을 사용할 수 있는데요, 바로 flex-grow, flex-shrink, 그리고 flex-basis를 이용하는 것입니다. flex-basis는 기준이 되는 길이값으로, 기본적으로는 요소의 height(주 축이 가로 방향일 때는 width)처럼 동작합니다. 부모 요소가 주 축 방향으로 가질 수 있는 길이에 여유가 있다면, 부모 요소의 길이는 이 basis의 합으로 자연스럽게 맞춰지겠죠. 그러나 자리가 부족한 경우에는 어떡할까요? 이 때는 자식 요소들이, 본인이 갖고 있는 flex-shrink 값에 비례하게 줄어들게 됩니다(0이면 줄어들 지 않습니다). 반대로 자리가 남으면 flex-grow에 비례하여 길어지게 되고요. 즉 Flexbox의 내부에서 자식 요소들은 여전히 부모 요소에게 basis만큼의 공간을 요구하긴 하지만, grow와 shrink에 따라서 부모 요소의 공간이 작거나 클 때 대응할 확대/축소에 대한 정책도 함께 제공한다는 것입니다. 그 이름처럼 보다 유연하고 너그러운 요청이라고 할 수 있죠."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "flex-grow, flex-shrink, flex-basis를 묶어 우리는 flex라는 단축 속성을 사용할 수 있습니다. Flexbox가 만연하게 사용되는 환경에서 이 단축 속성(특히 앞의 둘)은 요소들의 분류 계통으로써 사용될 수 있는데요, 이해를 돕기 위해 간단한 별명을 붙여 아래에 나열해보겠습니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": true, "text": "1-1족: 친화력이 좋은, 또는 빈 공간" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "`flex: 1 1 ?` 속성을 가진 요소들을 말합니다. 이 요소들은 부모 요소에 남은 공간이 있다면 계속 커지고, 부족하다면 계속 작아집니다. 이 요소는 항목이 늘어나거나 줄어들 수 있는 표의 셀처럼 개수와 형태가 가변적인 화면에 주로 사용됩니다. 그러나 flex-basis 이하로 줄어들 수 있다는 점, 그리고 형제 요소의 계통에 따라 완전히 사라질 수도 있다는 점에서 위험성이 존재하기도 하죠. 이 친구들을 가장 무난하게 사용하는 방법은 바로 다른 여러 1-1족들과 함께 사용하는 것입니다. 이들은 공간이 부족하면 모두 조금씩 줄어들고, 남으면 모두 조금씩 늘어나느 식으로 하여 허용된 공간을 가득 매울 것입니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "이 1-1족들을 사용할 수 있는 재미있는 방식 중 하나는 바로 간격입니다. 가로 Flexbox에서 두 개의 요소를 양쪽 끝에 배치하고 싶을 때, 우리는 보통 'justify-content: space-between'을 사용하곤 하는데요, 그 대신 `flex: 1 1 {최소 간격}`이 적용된 빈 <div> 태그를 사이에 둠으로써 같은 효과를 낼 수도 있습니다. 1-1족을 요소 사이의 빈 공간으로 사용하는 것이죠. 이 방식은 양쪽 요소와 grow의 값을 조정함으로써 자연스럽게 길이를 조절할 수 있는 등 몇 가지의 이점을 제공합니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": true, "text": "0-0족: 딱딱이들" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "이 부류의 요소들은 오직 자신의 flex-basis만큼의 길이를 요구할 뿐, 어떤 유연함도 허용하지 않습니다. 그렇기에 공간이 부족해지거나 남아도 언제나 "
              },
              { "bold": true, "text": "고정된 몫" },
              { "bold": false, "text": "을 차지해야 하는 페이지의 " },
              { "bold": true, "text": "헤더" },
              { "bold": false, "text": "나 표의 " },
              { "bold": true, "text": "라벨" },
              {
                "bold": false,
                "text": "과 같은 요소가 여기로 분류될 수 있습니다. 화면의 내용이 적다고 헤더의 높이가 길어지거나, 반대로 내용이 많다고 헤더의 높이가 줄어들면 좀 이상하겠죠? 이런 요소들은 Flexbox 내부에 있더라도 전혀 유연하지 않은 0-0족으로 구성하는 것이 좋습니다.  또한, 0-0족을 이용하면 부모 요소에 쉽게 스크롤을 생기게 할 수 있습니다. 아래 1-0족과 더불어서 말이죠."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": true, "text": "1-0족: 가득 찬 화면의 주 컨텐츠" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "1-0족은 빈 공간 만큼 늘어나기는 하지만, 절대 flex-basis 이하로 줄어들지는 않습니다. 일종의 최소 길이를 확보하고 있는 것인데요, 이는 본문과 같은 주 컨텐츠에 제일 잘 사용될 수 있습니다. 우리가 무언가로 가득 찬 화면을 만들고 싶다고 해봅시다. 해당 화면에 요소가 부족하다면, 존재하는 요소들이 조금씩 확장하여 화면을 가득 채우면 좋겠죠. 그러나 이 내용들은 중요하기 때문에 또한 잘리거나 너무 작아지는 일이 없어야 합니다. 따라서 1-1족으로 만들기보다는, 주로 `flex: 1 0 auto` 속성을 지닌 1-0족으로 만들어 요소가 너무 많아 붐비는 화면에서는 자연스럽게 부모 요소에 스크롤을 생성하는 게 좋습니다. 본문을 담기에 아주 적절한 종족 아닌가요?"
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": true, "text": "0-1족: 장식 요소들" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "제 경험상 자주 사용되는 부류는 아닙니다. flex-basis를 최대 값으로 가지고 있고, 공간이 부족할 경우 자연스럽게 줄어드는 요소들이죠. flex-shrink 값이 존재한다는 점에서 의도한 길이 이하로 줄어들 위험성을 인지해야 합니다. 주로 쓰이는 곳은 그렇게 중요하지 않는 장식적 요소, 그 중에서도 1-1족처럼 계속 늘어날 경우 왜곡되거나 깨질 수 있는 종류의 장식들에 사용될 수 있겠습니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "text": "이러한 분류는 Flexbox의 내부로부터 작용하는 힘, 다시 말해 자식 요소가 부모에게 길이를 요청하는 정책을 바탕으로 UI 컴포넌트들을 나누어 본 것입니다. 이 외에도 여러 특징적인 정책들이 있겠지만 더 나열하지는 않겠습니다. ",
                "bold": false
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "" }] },
          { "type": "PARAGRAPH", "children": [{ "text": "두 가지 힘을 이용한 레이아웃의 모듈화", "bold": true }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "text": "지금까지 Flexbox에 작용하는 두 힘에 대해 알아보았습니다. 이 힘은 Flexbox라는 레이아웃 시스템을 이용하여 화면에 요소들을 배치함에 있어 ",
                "bold": false
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "여기서 주목할 점은 이 두 힘의 주체와 객체가 명확하게 구분된다는 것입니다. 방향과 정렬은 부모가 자식에게 합니다(-self 속성을 이용한 예외가 아니라면 말입니다.) 반대로 주 축 방향으로의 길이는 자식이 부모에게 요청하죠. 이렇게 유연하면서도 엄격한 구조로 레이아웃을 바라보면 우리는 레이아웃의 유지보수가 어렵다는, 글의 첫머리에서 하소연한 고민거리를 해결할 수 있습니다. 그 해결책은 바로 레이아웃의 "
              },
              { "bold": true, "text": "모듈화" },
              { "bold": false, "text": "입니다." }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "UI 구현 과정에서 일어나는 모듈화의 대표적인 예시는 디자인 시스템입니다. 프론트엔드 개발자는 디자인 시스템을 바탕으로 연관된 스타일 속성을 묶어 재사용하거나, 버튼이나 제목과 같은 요소 자체를 스타일과 함께 디자인 컴포넌트로 묶어 재사용합니다. 스타일을 모듈화한 것이죠. 그런데 앞서 말했듯 레이아웃은 같은 방식으로 모듈화하기 어렵습니다. 어떤 레이아웃, 즉 어떤 길이와 폭과 overflow 속성과 쌓임 맥락을 가진 화면에 우리의 디자인 컴포넌트가 놓일 지 모르기 때문입니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "하지만 우리가 Flexbox를 이용하여 레이아웃을 작업한다면 모듈화가 가능합니다. 우리는 디자인 컴포넌트를 만들 때, "
              },
              { "bold": true, "text": "부모 요소에게 어떤 힘을 가할지" },
              {
                "bold": false,
                "text": " 미리 정해둘 수 있습니다. `flex` 속성을 이용해서 말이죠. 이 컴포넌트가 헤더라면 `flex: 0 0 40px`을, 본문이라면 `flex: 1 0 auto`를 선언해두는 게 적절할 겁니다. 이는 `height: 40px`와 같은 식으로 고정값을 적용하거나 `width: 50%`처럼 어떤 상황일 지 모르는 부모 요소에 모든 것을 맡기는 것보다 훨씬 유연하고 안전합니다."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "반대로 디자인 컴포넌트를 특정 레이아웃의 맥락 아래 배치할 때에는, `flex-direction`과  각종 정렬 속성을 이용하여 자식 요소에 힘을 가할 수 있습니다. 뿐만 아니라 위의 예시처럼 자식 요소들이 부모 레이아웃에 대해 유연성을 확보하고 있다면, 부모 요소의 크기, padding과 gap을 조정함으로써 자연스럽게 자식 요소의 크기에 영향을 줄 수도 있습니다. 그 때 그 때 디자인 컴포넌트의 스타일링 코드에 if문을 추가하지 않고도 말이죠. 자 이제 우리의 컴포넌트들은 레이아웃에 대해서도 내부와 외부를 격리하고, 서로 독립적으로 "
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "Flexbox가 기존의 문제를 단번에 해결할 만능 열쇠는 아닙니다. 특히 이러한 방식의 레이아웃을 도입하기가 까다로운 점은, 디자이너와 기획자도 "
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "다시 말해 디자인 시스템을 고안하는 과정 자체가 Flexbox에 친화적이어야 합니다. 저는 "
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": true, "text": "" }] }
        ]
      },
      {
        "id": "inXtGS8859oi3v28PSSoA",
        "title": "new box 7",
        "type": "INNER_BOX",
        "children": [
          { "type": "PARAGRAPH", "children": [{ "text": "'Pourable' 디자인 시스템", "bold": true }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "우리가 작업할 화면에 고정 높이 60px짜리 헤더가 있다고 가정해봅시다. 그 밑으로는 몇 가지의 메뉴 버튼들이 세로 방향으로 나열됩니다. 문제는 우리의 우유부단한 기획자가 어떤 버튼을 이 화면에 노출할 지 고민 중일 때 일어납니다. 일단 세 개의 버튼만 넣자고 하고, 디자이너는 이들이 동일한 높이로 화면을 가득 채우는 것을 상상합니다. 우리는 아래와 같이 코드를 짜게 될 겁니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": ".menu-button {" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  height: calc((100% - 60px) / 3)" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "}" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "아뿔싸, 기획자가 버튼 두 개를 추가했습니다. 그런데 디자이너가 그 중 하나는 중요한 버튼이니 크기를 키우자고 하네요. 우리는 코드가 복잡해지는 것에 양심의 가책을 느끼며 주석을 추가합니다."
              }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": ".menu-button-normal {" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              { "bold": false, "text": "  height: calc(100% - 80px) / 4; /* 헤더 60px, 큰 버튼은 height 20px 증가  */" }
            ]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "}" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              {
                "bold": false,
                "text": "그러나 얼마 후 데이터 분석가가 좋지 않은 A/B 테스트 결과를 말해줍니다. 그는 중요하지 않은 버튼 두 개는 한 줄에 배치하고 세로폭을 줄이고, 중심 버튼의 크기는 더욱 키우고자 합니다. 뿐만 아니라 QA 담당자가 세로폭이 좁은 기기에서는 세로 스크롤이 필요하다고 말하네요. 우리는 버튼의 세로폭을 결정하던 기존의 코드를 완전히 뜯어 고쳐야 합니다. 아래와 같은 알 수 없는 속성과 선택자들로 가득한 CSS 파일에서 말이죠."
              }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [{ "bold": false, "text": ".main-menu-page__menu-button-normal__not-hidden {" }]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  display: flex;" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  align-items: center;" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  justify-content: center;" }] },
          {
            "type": "PARAGRAPH",
            "children": [{ "bold": false, "text": "  font-size: var(--typography-label-normal-01);" }]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  text-align: center;" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  width: 100%;" }] },
          {
            "type": "PARAGRAPH",
            "children": [
              { "bold": false, "text": "  height: calc(100% - 80px) / 4; /* 헤더 60px, 큰 버튼은 height 20px 증가  */" }
            ]
          },
          {
            "type": "PARAGRAPH",
            "children": [{ "bold": false, "text": "  background-color: var(--button-background-color-red-01);" }]
          },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  overflow: hidden;" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "  /* ...그리고 많은 코드들이 더... */" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "}" }] },
          { "type": "PARAGRAPH", "children": [{ "bold": false, "text": "그렇게 극단적인 예시만은 아닙니다. " }] }
        ]
      }
    ]
  },
  "updatedAt": 1734876918701
}
